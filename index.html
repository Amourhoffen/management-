<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FocusBoard ‚Äî Pro Task Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Define CSS Variables for Dark Mode (default) */
        :root {
            --primary-color: #4f46e5; /* Indigo 600 */
            --primary-color-rgb: 79, 70, 229; /* RGB values for primary color */
            --secondary-color: #6366f1; /* Indigo 500 for hover */
            --bg-dark: #1f2937; /* Darker gray background */
            --bg-card: #2d3748; /* Darker gray for cards (solid base) */
            --text-light: #e5e7eb; /* Light gray text */
            --text-muted: #9ca3af; /* Muted gray text */
            --border-color: #4b5563; /* Darker border */
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* Softer shadow */
            --success-color: #10b981; /* Emerald */
            --warning-color: #f59e0b; /* Amber */
            --danger-color: #ef4444; /* Red */
            --accent-blue: #3b82f6; /* Blue 500 */
            --accent-purple: #a855f7; /* Purple 500 */
            --accent-green: #22c55e; /* Green 500 */
            --glass-bg: rgba(45, 55, 72, 0.7); /* bg-card with transparency for glass */
            --glass-border: rgba(75, 85, 99, 0.3); /* border-color with transparency for glass */
            --heading-color: var(--primary-color); /* Default heading color for light mode */
        }

        /* Light Mode Variables */
        body.light-mode {
            --primary-color: #4f46e5; /* Indigo 600 */
            --primary-color-rgb: 79, 70, 229; /* RGB values for primary color */
            --secondary-color: #6366f1; /* Indigo 500 for hover */
            --bg-dark: #f3f4f6; /* Light gray background */
            --bg-card: #ffffff; /* White (solid base) */
            --text-light: #1f2937; /* Dark gray text */
            --text-muted: #6b7280; /* Medium gray text */
            --border-color: #d1d5db; /* Light border */
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Softer shadow */
            --success-color: #059669; /* Darker Emerald */
            --warning-color: #d97706; /* Darker Amber */
            --danger-color: #dc2626; /* Darker Red */
            --glass-bg: rgba(255, 255, 255, 0.7); /* White with transparency for glass */
            --glass-border: rgba(209, 213, 219, 0.3); /* Light border with transparency for glass */
            --heading-color: var(--primary-color); /* Heading color remains primary in light mode */
        }

        body.dark-mode {
            --heading-color: var(--text-light); /* Heading color becomes light text in dark mode */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* General Styles */
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }
        .btn-primary:hover {
            background-color: var(--secondary-color);
            transform: translateY(-1px);
        }
        .btn-primary:active {
            transform: translateY(0);
        }
        .btn-secondary {
            background-color: var(--text-muted);
            color: white;
            padding: 0.8rem 1.8rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }
        .btn-secondary:hover {
            background-color: var(--text-light);
            color: var(--bg-dark);
            transform: translateY(-1px);
        }
        .btn-secondary:active {
            transform: translateY(0);
        }
        .text-primary { color: var(--primary-color); }
        .text-secondary { color: var(--text-muted); }
        .border-primary { border-color: var(--primary-color); }
        .input-field {
            background-color: var(--bg-dark); /* Inputs remain solid for clarity */
            border: 1px solid var(--border-color);
            color: var(--text-light);
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-field:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb), 0.3);
            outline: none;
        }

        /* Glassmorphism effect for panels and cards */
        .glass-card {
            background-color: var(--glass-bg);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: var(--box-shadow);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        /* Header Specific */
        header {
            padding: 1rem 2rem;
            border-radius: 0 0 0.75rem 0.75rem;
            box-shadow: var(--box-shadow);
        }
        header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--heading-color); /* Apply dynamic heading color */
        }

        /* Task Group Icon (No change, remains solid) */
        .task-group-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            margin-right: 1rem;
        }
        .task-group-icon.todo { background-color: var(--accent-blue); }
        .task-group-icon.in-progress { background-color: var(--accent-purple); }
        .task-group-icon.completed { background-color: var(--accent-green); }
        .task-group-icon.backlog { background-color: var(--text-muted); }

        /* Task List Item (Remains solid for better readability within columns) */
        .task-list-item {
            background-color: var(--bg-dark); /* Keep solid background for task items */
            border: 1px solid var(--border-color);
            border-radius: 0.6rem;
            padding: 0.8rem 1rem;
            margin-bottom: 0.6rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            cursor: pointer;
            transition: transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
        }
        .task-list-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        .task-list-item.completed {
            opacity: 0.7;
            text-decoration: line-through;
            color: var(--text-muted);
            border-color: var(--success-color);
        }
        .task-status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.75rem;
            flex-shrink: 0;
        }
        .task-status-indicator.pending { background-color: var(--text-muted); }
        .task-status-indicator.in-progress { background-color: var(--warning-color); }
        .task-status-indicator.completed { background-color: var(--success-color); }
        .task-status-indicator.backlog { background-color: var(--text-muted); }

        .task-title-row {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 0.25rem;
        }
        .task-meta-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Due Date Badge */
        .due-date-badge {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            padding: 0.2rem 0.5rem;
            border-radius: 0.3rem;
            font-size: 0.7rem;
            font-weight: 600;
            color: white;
            white-space: nowrap;
        }
        .due-date-badge.green { background-color: var(--success-color); }
        .due-date-badge.yellow { background-color: var(--warning-color); }
        .due-date-badge.red { background-color: var(--danger-color); }

        /* Date Picker (remains solid) */
        .date-picker-nav {
            display: flex;
            justify-content: space-around;
            padding: 0.5rem 0;
            background-color: var(--bg-dark);
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .date-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
            flex-shrink: 0;
            width: 60px;
        }
        .date-item:hover {
            background-color: rgba(var(--primary-color-rgb), 0.1);
        }
        .date-item.active {
            background-color: var(--primary-color);
            color: white;
        }
        .date-day {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-muted);
        }
        .date-num {
            font-size: 1.25rem;
            font-weight: 700;
        }
        .date-item.active .date-day {
            color: white;
        }

        /* Custom Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Slight transparency to see background blur */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            /* This will now use glass-card for its styling */
            position: relative;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            transform: translateY(-20px);
            opacity: 0;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 1.75rem;
            cursor: pointer;
            color: var(--text-muted);
            transition: color 0.2s;
        }

        .modal-close-btn:hover {
            color: var(--text-light);
        }

        .modal-content h3 {
            font-size: 1.75rem;
            color: var(--heading-color); /* Apply dynamic heading color */
        }

        /* Tab Styles (Adjusted for new layout) */
        .tab-buttons {
            background-color: transparent; /* Background of the container is transparent */
            border-bottom: none;
            margin-bottom: 1.5rem;
            border-radius: 0;
            justify-content: flex-start;
            gap: 0.75rem;
            display: flex;
        }
        .tab-button {
            /* Now uses glass-card for its base styling */
            padding: 0.8rem 1.5rem;
            border-radius: 0.6rem;
            color: var(--text-muted);
            transition: background-color 0.2s, color 0.2s, box-shadow 0.2s, transform 0.2s;
        }
        .tab-button.active {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 6px 12px rgba(var(--primary-color-rgb), 0.2);
            transform: translateY(-2px);
            border: 1px solid var(--primary-color); /* Active tab has solid border */
        }
        .tab-button:hover:not(.active) {
            background-color: var(--glass-bg); /* Hover also uses glass effect */
            color: var(--primary-color);
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
            flex-direction: column;
            flex-grow: 1;
            gap: 2rem;
            width: 100%;
            /* Animation for tab content */
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        .tab-content.active {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        /* Kanban Board Styles */
        .kanban-board {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive columns */
            gap: 1.5rem;
            height: calc(100vh - 200px); /* Adjust height for scrolling */
            overflow-y: auto;
        }
        .kanban-column {
            /* Now uses glass-card for its base styling */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 200px; /* Minimum height for columns */
            transition: border-color 0.2s ease-in-out;
        }
        .kanban-column.drag-over {
            border-color: var(--primary-color);
            border-width: 2px;
        }
        .kanban-column-header {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--heading-color); /* Apply dynamic heading color */
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .kanban-column-count {
            background-color: var(--text-muted);
            color: white;
            font-size: 0.75rem;
            padding: 0.2rem 0.6rem;
            border-radius: 9999px; /* full rounded */
        }
        .kanban-tasks {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 0.5rem; /* Space for scrollbar */
        }

        /* Focus Mode Styles */
        #focus-mode-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-dark); /* Solid background for focus mode */
            color: var(--text-light);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #focus-mode-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .focus-timer-display {
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }
        .focus-task-name {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            text-align: center;
        }
        .focus-task-description {
            font-size: 1.2rem;
            color: var(--text-muted);
            text-align: center;
            max-width: 600px;
            margin-bottom: 2rem;
        }
        .focus-controls button {
            margin: 0 0.5rem;
        }
        .focus-checklist-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .focus-checklist-item input[type="checkbox"] {
            margin-right: 0.5rem;
            width: 1.25rem;
            height: 1.25rem;
        }

        /* Chart.js container */
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
            margin-top: 2rem;
        }

        /* Daily Planner Grid Styles (remains solid) */
        .daily-grid-container {
            display: grid;
            grid-template-columns: 60px 1fr;
            gap: 0.5rem;
            max-height: calc(100vh - 250px);
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 0.5rem;
            background-color: var(--bg-dark);
        }
        .time-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-muted);
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            position: sticky;
            left: 0;
            z-index: 10;
            background-color: var(--bg-dark);
        }
        .time-label-item {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 0.5rem;
        }
        .daily-grid {
            display: grid;
            grid-template-rows: repeat(v-bind(gridRows), 40px);
            grid-auto-rows: 40px;
            position: relative;
            border-left: 1px solid var(--border-color);
        }
        .grid-line {
            position: absolute;
            left: 0;
            width: 100%;
            border-bottom: 1px dashed var(--border-color);
            z-index: 1;
        }
        .daily-block {
            position: absolute;
            left: 0;
            width: calc(100% - 4px);
            background-color: var(--primary-color);
            color: white;
            border-radius: 0.4rem;
            padding: 0.2rem 0.5rem;
            font-size: 0.8rem;
            font-weight: 500;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            z-index: 2;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .daily-block:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .daily-block.selected-start {
            border: 2px dashed var(--warning-color);
        }
        .daily-block.selected-end {
            border: 2px solid var(--success-color);
        }

        .live-time-indicator {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: var(--danger-color);
            z-index: 3;
            pointer-events: none;
            transition: top 60s linear;
        }

        /* Responsive adjustments */
        @media (min-width: 1024px) { /* Desktop layout */
            main {
                display: grid;
                grid-template-columns: 1fr 2fr 1fr; /* Left, Middle, Right columns */
                gap: 2rem;
            }
            .tab-buttons {
                display: none; /* Hide tabs on desktop, use columns */
            }
            .tab-content {
                display: flex !important; /* Always show all content on desktop */
                flex-direction: column;
                gap: 2rem;
            }
            #kanban-tab { grid-column: 1 / 2; }
            #daily-planner-tab { grid-column: 2 / 3; }
            #reflection-tab { grid-column: 3 / 4; }
        }

        @media (max-width: 1023px) { /* For screens smaller than large (lg) breakpoint */
            header h1 {
                font-size: 1.5rem;
            }
            .tab-buttons {
                justify-content: space-between;
                padding: 0.5rem;
                margin-bottom: 1rem;
            }
            .tab-button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            .glass-card { /* Adjust padding for smaller screens */
                padding: 1rem;
            }
            .kanban-board {
                height: auto; /* Allow height to adjust on mobile */
                overflow-y: visible;
            }
            .daily-grid-container {
                max-height: calc(100vh - 300px); /* Adjusted for mobile header/footer */
            }
        }

        @media (max-width: 767px) { /* For screens smaller than medium (md) breakpoint */
            header {
                flex-direction: column;
                align-items: flex-start;
                padding: 1rem;
            }
            header .flex.items-center.space-x-4 {
                margin-top: 0.75rem;
                width: 100%;
                justify-content: space-between;
            }
            main {
                padding: 1rem;
            }
            .tab-buttons {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
                position: fixed; /* Fixed bottom navbar */
                bottom: 0;
                left: 0;
                width: 100%;
                background-color: var(--glass-bg); /* Use glass-bg for fixed navbar */
                border-top: 1px solid var(--glass-border);
                z-index: 50;
                padding: 0.75rem 0.5rem;
                border-radius: 0.75rem 0.75rem 0 0; /* Rounded top corners */
                box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(10px); /* Apply blur to fixed navbar */
                -webkit-backdrop-filter: blur(10px);
            }
            .tab-button {
                flex-grow: 1;
                text-align: center;
                margin: 0 0.25rem;
                padding: 0.75rem 0.5rem;
            }
            .modal-content {
                padding: 1.5rem;
            }
            .modal-content h3 {
                font-size: 1.5rem;
            }
            /* Add padding to main content to prevent overlap with fixed navbar */
            main {
                padding-bottom: 6rem; /* Adjust based on navbar height */
            }
        }

        /* --- Loader Overlay Styles (Enhanced) --- */
        #loader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Darker, more immersive background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than other modals */
            color: white;
            font-size: 2.5rem; /* Larger font for main text */
            font-weight: 700; /* Bolder font */
            text-shadow: 0 0 15px rgba(0, 0, 0, 0.7); /* Stronger shadow */
            transition: opacity 0.7s ease-in-out, visibility 0.7s ease-in-out; /* Slower transition */
            opacity: 0;
            visibility: hidden;
            font-family: 'Inter', sans-serif; /* Ensure Inter font is used */
        }

        #loader-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .loader-spinner {
            border: 8px solid rgba(255, 255, 255, 0.2); /* Lighter, more subtle outer ring */
            border-top: 8px solid var(--primary-color); /* Primary color for the spinning part */
            border-radius: 50%;
            width: 80px; /* Larger spinner */
            height: 80px; /* Larger spinner */
            animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite; /* More professional animation curve */
            margin-bottom: 30px; /* More space below spinner */
            box-shadow: 0 0 15px rgba(var(--primary-color-rgb), 0.5); /* Glowing effect */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loader-text {
            font-size: 1.2rem; /* Smaller, supporting text size */
            font-weight: 500;
            color: rgba(255, 255, 255, 0.8); /* Slightly muted white */
            letter-spacing: 2px; /* Add some letter spacing */
            margin-top: 15px; /* Space between "EVEXA BUDDY" and spinner */
        }

        .loader-main-text {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary-color); /* Use primary color for main text */
            margin-bottom: 10px;
            text-transform: uppercase; /* Uppercase for impact */
            letter-spacing: 4px; /* More letter spacing for main text */
        }
    </style>
</head>
<body class="light-mode">
    <div class="min-h-screen flex flex-col">
        <header class="glass-card flex items-center justify-between border-b border-color">
            <div class="flex items-center">
                <h1>EveXa ‚Äî Pro Task Manager</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="open-focus-mode-btn" class="btn-secondary">üéØ Focus</button>
                <button id="theme-toggle" class="p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path id="theme-icon-path" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h1M4 12H3m15.325 5.325l-.707.707M6.364 6.364l-.707-.707M17.657 6.343l.707-.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
                    </svg>
                </button>
                <button id="show-settings-btn" class="btn-secondary">Settings</button>
            </div>
        </header>

        <main class="flex-1 p-6 flex flex-col">
            <div class="tab-buttons lg:hidden">
                <button class="tab-button glass-card active" data-tab="kanban">‚úÖ Tasks</button>
                <button class="tab-button glass-card" data-tab="daily-planner">üìÖ Planner</button>
                <button class="tab-button glass-card" data-tab="reflection">üß† Reflect</button>
            </div>

            <div id="kanban-tab" class="tab-content active flex-1">
                <div class="glass-card flex-1">
                    <h2 class="text-xl font-semibold mb-4">Task Board</h2>
                    <button id="add-task-kanban-btn" class="btn-primary w-full mb-4">Add New Task</button>
                    <div class="kanban-board">
                        <div id="kanban-todo" class="kanban-column glass-card" data-category="todo">
                            <h3 class="kanban-column-header">To-Do <span class="kanban-column-count">0</span></h3>
                            <div class="kanban-tasks"></div>
                        </div>
                        <div id="kanban-in-progress" class="kanban-column glass-card" data-category="in-progress">
                            <h3 class="kanban-column-header">In Progress <span class="kanban-column-count">0</span></h3>
                            <div class="kanban-tasks"></div>
                        </div>
                        <div id="kanban-completed" class="kanban-column glass-card" data-category="completed">
                            <h3 class="kanban-column-header">Completed <span class="kanban-column-count">0</span></h3>
                            <div class="kanban-tasks"></div>
                        </div>
                        <div id="kanban-backlog" class="kanban-column glass-card" data-category="backlog">
                            <h3 class="kanban-column-header">Backlog / Someday <span class="kanban-column-count">0</span></h3>
                            <div class="kanban-tasks"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="daily-planner-tab" class="tab-content flex-1">
                <div class="glass-card flex-1">
                    <h2 class="text-xl font-semibold mb-4">Daily Planner</h2>
                    <div class="flex flex-wrap gap-2 mb-4">
                        <button id="save-template-btn" class="btn-secondary">Save Template</button>
                        <button id="load-template-btn" class="btn-secondary">Load Template</button>
                        <button id="clear-daily-plan-btn" class="btn-secondary bg-red-500 hover:bg-red-600">Clear Plan</button>
                    </div>

                    <div class="daily-grid-container">
                        <div id="time-labels" class="time-labels">
                            </div>
                        <div id="daily-grid" class="daily-grid">
                            <div id="live-time-indicator" class="live-time-indicator"></div>
                        </div>
                    </div>

                    <h2 class="text-xl font-semibold mt-6 mb-4">Daily Summary</h2>
                    <div class="chart-container">
                        <canvas id="daily-summary-chart"></canvas>
                    </div>
                </div>
            </div>

            <div id="reflection-tab" class="tab-content flex-1">
                 <div class="glass-card">
                    <h2 class="text-xl font-semibold mb-4">Daily Reflection</h2>
                    <button id="start-reflection-btn" class="btn-primary w-full">Reflect on Today</button>
                    <div id="daily-log-summary" class="mt-4 text-sm text-secondary">
                        <p class="text-sm text-secondary">No reflections yet. Reflect on your day to see insights!</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="add-edit-task-modal" class="modal-overlay">
        <div class="modal-content glass-card">
            <span class="modal-close-btn" data-modal-id="add-edit-task-modal">&times;</span>
            <h3 class="text-xl font-bold mb-4" id="add-edit-task-modal-title">Add New Task</h3>
            <input type="hidden" id="task-id-to-edit">
            <div class="mb-4">
                <label for="task-name-input" class="block text-secondary mb-2">Task Name:</label>
                <input type="text" id="task-name-input" placeholder="e.g., Complete project report" class="input-field w-full">
                <div id="suggestion-box" class="absolute glass-card border border-color rounded-md shadow-lg mt-1 w-full z-10 hidden"></div>
            </div>
            <div class="mb-4">
                <label for="task-description-input" class="block text-secondary mb-2">Description (optional):</label>
                <textarea id="task-description-input" placeholder="Details about the task" class="input-field w-full h-24"></textarea>
            </div>
            <div class="mb-4">
                <label for="task-duration-input" class="block text-secondary mb-2">Estimated Duration (hours):</label>
                <input type="number" id="task-duration-input" value="1" min="0.5" step="0.5" class="input-field w-full">
            </div>
            <div class="mb-4">
                <label for="task-category-select" class="block text-secondary mb-2">Category:</label>
                <select id="task-category-select" class="input-field w-full">
                    <option value="todo">To-Do</option>
                    <option value="in-progress">In Progress</option>
                    <option value="completed">Completed</option>
                    <option value="backlog">Backlog / Someday</option>
                </select>
            </div>
            <div class="mb-4">
                <label for="task-due-date-input" class="block text-secondary mb-2">Due Date:</label>
                <input type="date" id="task-due-date-input" class="input-field w-full">
            </div>
            <button id="save-task-btn" class="btn-primary w-full">Save Task</button>
        </div>
    </div>

    <div id="task-details-modal" class="modal-overlay">
        <div class="modal-content glass-card">
            <span class="modal-close-btn" data-modal-id="task-details-modal">&times;</span>
            <h3 class="text-xl font-bold mb-4">Task Details</h3>
            <p class="mb-2"><strong class="text-secondary">Name:</strong> <span id="detail-task-name"></span></p>
            <p class="mb-2"><strong class="text-secondary">Description:</strong> <span id="detail-task-description"></span></p>
            <p class="mb-2"><strong class="text-secondary">Estimated Duration:</strong> <span id="detail-task-duration"></span> hours</p>
            <p class="mb-2"><strong class="text-secondary">Category:</strong> <span id="detail-task-category"></span></p>
            <p class="mb-2"><strong class="text-secondary">Due Date:</strong> <span id="detail-task-due-date"></span></p>
            <p class="mb-4"><strong class="text-secondary">Status:</strong> <span id="detail-task-status"></span></p>
            <div class="flex justify-end space-x-2">
                <button id="mark-completed-btn" class="btn-primary">Mark Completed</button>
                <button id="edit-task-btn" class="btn-secondary">Edit Task</button>
                <button id="delete-task-btn" class="btn-secondary">Delete Task</button>
            </div>
        </div>
    </div>

    <div id="daily-block-modal" class="modal-overlay">
        <div class="modal-content glass-card">
            <span class="modal-close-btn" data-modal-id="daily-block-modal">&times;</span>
            <h3 class="text-xl font-bold mb-4" id="daily-block-modal-title">Add New Block</h3>
            <input type="hidden" id="daily-block-id-to-edit">
            <div class="mb-4">
                <label for="daily-block-title-input" class="block text-secondary mb-2">Block Title:</label>
                <input type="text" id="daily-block-title-input" placeholder="e.g., Study Physics" class="input-field w-full">
            </div>
            <div class="mb-4">
                <label for="daily-block-type-select" class="block text-secondary mb-2">Type:</label>
                <select id="daily-block-type-select" class="input-field w-full">
                    <option value="study">üìò Study</option>
                    <option value="class">üßë‚Äçüè´ Class</option>
                    <option value="break">üçΩÔ∏è Break</option>
                    <option value="exercise">üèãÔ∏è Exercise</option>
                    <option value="rest">üí§ Rest</option>
                    <option value="other">Other</option>
                </select>
            </div>
            <div class="mb-4">
                <label for="daily-block-start-time-input" class="block text-secondary mb-2">Start Time:</label>
                <input type="time" id="daily-block-start-time-input" class="input-field w-full">
            </div>
            <div class="mb-4">
                <label for="daily-block-end-time-input" class="block text-secondary mb-2">End Time:</label>
                <input type="time" id="daily-block-end-time-input" class="input-field w-full">
            </div>
            <button id="save-daily-block-btn" class="btn-primary w-full">Save Block</button>
            <button id="delete-daily-block-btn" class="btn-secondary w-full mt-2 bg-red-500 hover:bg-red-600 hidden">Delete Block</button>
        </div>
    </div>

    <div id="reflection-modal" class="modal-overlay">
        <div class="modal-content glass-card">
            <span class="modal-close-btn" data-modal-id="reflection-modal">&times;</span>
            <h3 class="text-xl font-bold mb-4">Daily Reflection</h3>
            <div class="mb-4">
                <label class="block text-secondary mb-2">Tasks Completed:</label>
                <div id="reflection-tasks-list" class="space-y-2">
                    </div>
            </div>
            <div class="mb-4">
                <label for="distraction-input" class="block text-secondary mb-2">What distracted you the most today?</label>
                <input type="text" id="distraction-input" class="input-field w-full rounded-md border">
            </div>
            <div class="mb-4">
                <label class="block text-secondary mb-2">Mood Rating:</label>
                <div class="flex justify-around text-4xl">
                    <span class="cursor-pointer hover:scale-110 transition-transform" data-mood="angry">üò†</span>
                    <span class="cursor-pointer hover:scale-110 transition-transform" data-mood="sad">üòî</span>
                    <span class="cursor-pointer hover:scale-110 transition-transform" data-mood="neutral">üòê</span>
                    <span class="cursor-pointer hover:scale-110 transition-transform" data-mood="happy">üôÇ</span>
                    <span class="cursor-pointer hover:scale-110 transition-transform" data-mood="excited">üòÅ</span>
                </div>
                <input type="hidden" id="mood-rating">
            </div>
            <button id="submit-reflection-btn" class="btn-primary w-full">Submit Reflection</button>
        </div>
    </div>

    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content glass-card">
            <span class="modal-close-btn" data-modal-id="settings-modal">&times;</span>
            <h3 class="text-xl font-bold mb-4">Settings</h3>
            <div class="mb-4">
                <label for="distraction-message-input" class="block text-secondary mb-2">Custom Reminder Message:</label>
                <input type="text" id="distraction-message-input" placeholder="e.g., Stay focused!" class="input-field w-full rounded-md border">
            </div>
            <div class="mb-4">
                <label for="focus-duration-input" class="block text-secondary mb-2">Default Focus Session Duration (minutes):</label>
                <input type="number" id="focus-duration-input" value="25" min="5" step="5" class="input-field w-full rounded-md border">
            </div>
            <div class="mb-4">
                <label for="grid-start-time-input" class="block text-secondary mb-2">Daily Grid Start Time:</label>
                <input type="time" id="grid-start-time-input" class="input-field w-full">
            </div>
            <div class="mb-4">
                <label for="grid-end-time-input" class="block text-secondary mb-2">Daily Grid End Time:</label>
                <input type="time" id="grid-end-time-input" class="input-field w-full">
            </div>
            <div class="mb-4">
                <label for="grid-interval-select" class="block text-secondary mb-2">Daily Grid Interval:</label>
                <select id="grid-interval-select" class="input-field w-full">
                    <option value="30">30 minutes</option>
                    <option value="60">60 minutes</option>
                </select>
            </div>
            <button id="save-settings-btn" class="btn-primary w-full mb-4">Save Settings</button>
            <button id="export-data-btn" class="btn-secondary w-full mb-4">Export Data (JSON)</button>
            <button id="clear-all-data-btn" class="btn-secondary w-full bg-red-500 hover:bg-red-600">Clear All Data</button>
            <p class="text-sm text-secondary mt-4">Note: Focus Reminder AI uses predefined quotes.</p>
        </div>
    </div>

    <div id="message-box-modal" class="modal-overlay">
        <div class="modal-content glass-card text-center">
            <h3 id="message-box-title" class="text-xl font-bold mb-4"></h3>
            <p id="message-box-text" class="mb-6 text-secondary"></p>
            <div class="flex justify-center space-x-4">
                <button id="message-box-ok-btn" class="btn-primary">OK</button>
                <button id="message-box-cancel-btn" class="btn-secondary hidden">Cancel</button>
            </div>
        </div>
    </div>

    <div id="template-selection-modal" class="modal-overlay">
        <div class="modal-content glass-card">
            <span class="modal-close-btn" data-modal-id="template-selection-modal">&times;</span>
            <h3 class="text-xl font-bold mb-4">Load Template</h3>
            <div id="template-list" class="space-y-2 mb-4 glass-card">
                <p class="text-sm text-secondary">No templates saved yet.</p>
            </div>
            <button id="load-selected-template-btn" class="btn-primary w-full">Load Selected Template</button>
        </div>
    </div>

    <div id="focus-mode-overlay">
        <button id="focus-mode-close-btn" class="modal-close-btn">&times;</button>
        <p class="focus-timer-display" id="focus-timer-display">00:00</p>
        <h2 class="focus-task-name" id="focus-task-name"></h2>
        <p class="focus-task-description" id="focus-task-description"></p>
        <div class="flex flex-col items-start mb-6 w-full max-w-md">
            <h4 class="text-lg font-semibold mb-2">Checklist:</h4>
            <div id="focus-checklist-items" class="w-full">
                </div>
        </div>
        <div class="focus-controls flex space-x-4">
            <button id="focus-start-btn" class="btn-primary">Start</button>
            <button id="focus-pause-btn" class="btn-secondary">Pause</button>
            <button id="focus-reset-btn" class="btn-secondary">Reset</button>
            <button id="focus-complete-btn" class="btn-primary">Mark Completed</button>
        </div>
        <div class="mt-8">
            <audio id="ambient-sound-player" loop>
                <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
                Your browser does not support the audio element.
            </audio>
            <button id="toggle-ambient-sound" class="btn-secondary text-sm px-4 py-2">Toggle Ambient Sound</button>
        </div>
    </div>

    <div id="loader-overlay">
        <div class="loader-spinner"></div>
        <p class="loader-main-text">EVEXA BUDDY</p>
        <p class="loader-text">Loading your productivity journey...</p>
    </div>

    <script>
        // --- Global State Management ---
        const appState = {
            tasks: [], // { id, name, description, duration, category, dueDate, status ('todo', 'in-progress', 'completed', 'backlog') }
            categories: [
                { id: 'todo', name: 'To-Do', icon: 'üìù' },
                { id: 'in-progress', name: 'In Progress', icon: 'üöß' },
                { id: 'completed', name: 'Completed', icon: '‚úÖ' },
                { id: 'backlog', name: 'Backlog / Someday', icon: 'üì¶' }
            ],
            dailyBlocks: [], // { id, title, type, startTime, endTime, color }
            dailyTemplates: [], // { id, name, blocks: [] }
            currentDate: new Date(),
            activeCategoryFilter: null, // For Today's Tasks filter (all, in-progress, completed)
            dailyLogs: [], // { date: 'YYYY-MM-DD', productivityScore: 80, distractions: 'Social Media', mood: 'happy', completedTasks: [] }
            settings: {
                distractionMessage: "Stay focused on your tasks!",
                theme: 'light-mode',
                focusSessionDuration: 25 * 60, // 25 minutes in seconds
                dailyGridStartTime: '07:00', // 7 AM
                dailyGridEndTime: '23:00',   // 11 PM
                dailyGridInterval: 30,      // 30 minutes
            },
            focusMode: {
                isActive: false,
                currentTaskId: null,
                timerInterval: null,
                timeLeft: 25 * 60,
                isRunning: false,
            },
            productivityChart: null, // To hold the Chart.js instance for daily summary
            dailySummaryChart: null, // To hold the Chart.js instance for daily summary
        };

        // --- DOM Elements (Declared globally, assigned in initApp) ---
        let themeToggleBtn;
        let themeIconPath;
        let body;

        let addKanbanTaskBtn;

        // Daily Planner elements
        let dailyPlannerTab;
        let saveTemplateBtn;
        let loadTemplateBtn;
        let clearDailyPlanBtn;
        let timeLabelsContainer;
        let dailyGridContainer;
        let dailyGrid;
        let liveTimeIndicator;
        let dailySummaryChartCanvas;

        let startReflectionBtn;
        let dailyLogSummary;

        // Modals
        let addEditTaskModal;
        let addEditTaskModalTitle;
        let taskIdToEditInput;
        let taskNameInput;
        let taskDescriptionInput;
        let taskDurationInput;
        let taskCategorySelect;
        let taskDueDateInput;
        let saveTaskBtn;
        let suggestionBox;

        let taskDetailsModal;
        let detailTaskName;
        let detailTaskDescription;
        let detailTaskDuration;
        let detailTaskCategory;
        let detailTaskDueDate;
        let detailTaskStatus;
        let markCompletedBtn;
        let editTaskBtn;
        let deleteTaskBtn;

        let dailyBlockModal;
        let dailyBlockModalTitle;
        let dailyBlockIdToEditInput;
        let dailyBlockTitleInput;
        let dailyBlockTypeSelect;
        let dailyBlockStartTimeInput;
        let dailyBlockEndTimeInput;
        let saveDailyBlockBtn;
        let deleteDailyBlockBtn;

        let reflectionModal;
        let reflectionTasksList;
        let distractionInput;
        let moodRatingInput;
        let submitReflectionBtn;

        let settingsModal;
        let showSettingsBtn;
        let saveSettingsBtn;
        let customReminderMessageInput;
        let focusDurationInput; // New setting input
        let gridStartTimeInput; // New setting input
        let gridEndTimeInput;   // New setting input
        let gridIntervalSelect; // New setting input
        let exportDataBtn;
        let clearAllDataBtn;

        let messageBoxModal;
        let messageBoxTitle;
        let messageBoxText;
        let messageBoxOkBtn;
        let messageBoxCancelBtn; // New DOM element for cancel button

        let templateSelectionModal;
        let templateListContainer;
        let loadSelectedTemplateBtn;

        let tabButtons;
        let tabContents;

        // Kanban Columns
        let kanbanTodo;
        let kanbanInProgress;
        let kanbanCompleted;
        let kanbanBacklog;

        let kanbanTodoCount;
        let kanbanInProgressCount;
        let kanbanCompletedCount;
        let kanbanBacklogCount;

        // Focus Mode Elements
        let openFocusModeBtn;
        let focusModeOverlay;
        let focusTimerDisplay;
        let focusTaskName;
        let focusTaskDescription;
        let focusChecklistItems;
        let focusStartBtn;
        let focusPauseBtn;
        let focusResetBtn;
        let focusCompleteBtn;
        let ambientSoundPlayer;
        let toggleAmbientSoundBtn;
        let focusModeCloseBtn;

        // Loader Element
        let loaderOverlay;

        let draggedTaskId = null; // Global variable to hold the task ID being dragged

        // Daily Planner Interaction Variables
        let isDragging = false;
        let dragStartTime = null;
        let dragStartElement = null;
        let newBlockTempId = null; // To identify the block being created/dragged

        // --- Utility Functions ---

        /**
         * Generates a unique ID for tasks.
         * @returns {string} A unique ID.
         */
        function generateId() {
            return '_' + Math.random().toString(36).substr(2, 9);
        }

        /**
         * Displays a custom message box.
         * @param {string} title - The title of the message box.
         * @param {string} message - The message to display.
         * @param {Function} onOk - Callback function for OK button.
         * @param {string} okButtonText - Text for the OK button.
         * @param {Function} onCancel - Callback function for Cancel button (if present).
         * @param {string} cancelButtonText - Text for the Cancel button.
         */
        function showMessageBox(title, message, onOk = null, okButtonText = 'OK', onCancel = null, cancelButtonText = 'Cancel') {
            messageBoxTitle.textContent = title;
            messageBoxText.textContent = message;
            messageBoxOkBtn.textContent = okButtonText;

            // Clear previous listeners
            messageBoxOkBtn.onclick = null;
            messageBoxCancelBtn.onclick = null;

            messageBoxOkBtn.addEventListener('click', () => {
                closeModal('message-box-modal');
                if (onOk) onOk();
            });

            if (onCancel) {
                messageBoxCancelBtn.textContent = cancelButtonText;
                messageBoxCancelBtn.classList.remove('hidden');
                messageBoxCancelBtn.addEventListener('click', () => {
                    closeModal('message-box-modal');
                    onCancel();
                });
            } else {
                messageBoxCancelBtn.classList.add('hidden');
            }

            messageBoxModal.classList.add('active');
        }

        /**
         * Displays a confirmation box.
         * @param {string} title - The title of the confirmation box.
         * @param {string} message - The confirmation message.
         * @param {Function} onConfirm - Callback function if user confirms.
         * @param {Function} onCancel - Optional callback function if user cancels.
         */
        function showConfirmationBox(title, message, onConfirm, onCancel = () => {}) {
            showMessageBox(title, message, onConfirm, 'Confirm', onCancel, 'Cancel');
        }

        /**
         * Closes a modal.
         * @param {string} modalId - The ID of the modal element.
         */
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        /**
         * Formats seconds into MM:SS string.
         * @param {number} totalSeconds - The total number of seconds.
         * @returns {string} Formatted time string (MM:SS).
         */
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        /**
         * Gets the current date inYYYY-MM-DD format.
         * @param {Date} date - The date object.
         * @returns {string} Formatted date string.
         */
        function formatDateToYYYYMMDD(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        /**
         * Parses aYYYY-MM-DD string to a Date object.
         * @param {string} dateString - The date string inYYYY-MM-DD format.
         * @returns {Date} The Date object.
         */
        function parseYYYYMMDDToDate(dateString) {
            const [year, month, day] = dateString.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        /**
         * Calculates days left until a due date.
         * @param {string} dueDateString - Due date inYYYY-MM-DD format.
         * @returns {object} { daysLeft: number, status: 'green'|'yellow'|'red', text: string }
         */
        function getDueDateStatus(dueDateString) {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to start of day
            const dueDate = parseYYYYMMDDToDate(dueDateString);
            dueDate.setHours(0, 0, 0, 0); // Normalize to start of day

            const diffTime = dueDate.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            let status = 'green';
            let text = '';

            if (diffDays < 0) {
                status = 'red';
                text = 'Overdue';
            } else if (diffDays === 0) {
                status = 'yellow';
                text = 'Due Today';
            } else if (diffDays === 1) {
                status = 'yellow';
                text = 'Due Tomorrow';
            } else if (diffDays <= 7) {
                status = 'yellow';
                text = `${diffDays} days left`;
            } else {
                status = 'green';
                text = `${diffDays} days left`;
            }
            return { daysLeft: diffDays, status, text };
        }

        /**
         * Converts HH:MM time string to minutes from midnight.
         * @param {string} timeString - Time in HH:MM format.
         * @returns {number} Minutes from midnight.
         */
        function timeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }

        /**
         * Converts minutes from midnight to HH:MM time string.
         * @param {number} totalMinutes - Minutes from midnight.
         * @returns {string} Time in HH:MM format.
         */
        function minutesToTime(totalMinutes) {
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        // --- LocalStorage Management ---

        /**
         * Saves the current app state to LocalStorage.
         */
        function saveData() {
            try {
                // Temporarily remove Chart.js instances before stringifying
                const chartInstance1 = appState.productivityChart;
                const chartInstance2 = appState.dailySummaryChart;
                appState.productivityChart = null;
                appState.dailySummaryChart = null;

                localStorage.setItem('focusBoardAppState', JSON.stringify(appState));

                // Restore the Chart.js instances
                appState.productivityChart = chartInstance1;
                appState.dailySummaryChart = chartInstance2;

            } catch (e) {
                console.error("Error saving data to LocalStorage:", e);
                showMessageBox("Error", "Could not save your data. Please check browser storage settings.");
            }
        }

        /**
         * Loads app state from LocalStorage.
         */
        function loadData() {
            try {
                const savedState = localStorage.getItem('focusBoardAppState');
                if (savedState) {
                    const parsedState = JSON.parse(savedState);
                    if (parsedState && typeof parsedState === 'object') {
                        // Merge parsed state into appState, handling nested objects carefully

                        appState.tasks = parsedState.tasks || [];
                        appState.categories = appState.categories.map(defaultCat => {
                            const savedCat = (parsedState.categories || []).find(sc => sc.id === defaultCat.id);
                            return savedCat ? { ...defaultCat, ...savedCat } : defaultCat;
                        });
                        appState.dailyBlocks = parsedState.dailyBlocks || [];
                        appState.dailyTemplates = parsedState.dailyTemplates || [];
                        appState.currentDate = parsedState.currentDate ? new Date(parsedState.currentDate) : new Date();
                        appState.activeCategoryFilter = parsedState.activeCategoryFilter !== undefined ? parsedState.activeCategoryFilter : null;
                        appState.dailyLogs = parsedState.dailyLogs || [];

                        if (parsedState.settings && typeof parsedState.settings === 'object') {
                            Object.assign(appState.settings, parsedState.settings);
                        }

                        if (parsedState.focusMode && typeof parsedState.focusMode === 'object') {
                            Object.assign(appState.focusMode, parsedState.focusMode);
                            appState.focusMode.timerInterval = null;
                            appState.focusMode.isRunning = false;
                            appState.focusMode.timeLeft = (parsedState.focusMode.timeLeft !== undefined && parsedState.focusMode.timeLeft !== null)
                                ? parsedState.focusMode.timeLeft
                                : appState.settings.focusSessionDuration;
                        } else {
                            appState.focusMode = {
                                isActive: false,
                                currentTaskId: null,
                                timerInterval: null,
                                timeLeft: appState.settings.focusSessionDuration,
                                isRunning: false,
                            };
                        }

                        // Post-processing for tasks (defaults if properties are missing)
                        appState.tasks = appState.tasks.map(task => ({
                            ...task,
                            category: task.category || 'todo',
                            dueDate: task.dueDate || formatDateToYYYYMMDD(new Date()),
                            status: task.status || 'todo'
                        }));

                    } else {
                        console.warn("Parsed state from LocalStorage was invalid or not an object:", parsedState);
                        // Do not call clearAllData(false) here. Just proceed with default appState.
                        showMessageBox("Data Load Warning", "Your saved data could not be fully loaded. Starting with a fresh state for this session. Your old data might still be in local storage.");
                    }
                }
            } catch (e) {
                console.error("Error loading data from LocalStorage:", e);
                // Do not call clearAllData(false) here. Just proceed with default appState.
                showMessageBox("Data Load Error", "An error occurred while loading your data. Starting with a fresh state for this session. Your old data might still be in local storage.");
            }
        }

        /**
         * Clears all app data from LocalStorage.
         * @param {boolean} showConfirmation - Whether to show a confirmation dialog.
         */
        function clearAllData(showConfirmation = true) {
            if (showConfirmation) {
                showConfirmationBox(
                    "Confirm Clear Data",
                    "Are you sure you want to clear all your data? This cannot be undone.",
                    () => {
                        localStorage.removeItem('focusBoardAppState');
                        Object.assign(appState, {
                            tasks: [],
                            categories: [
                                { id: 'todo', name: 'To-Do', icon: 'üìù' },
                                { id: 'in-progress', name: 'In Progress', icon: 'üöß' },
                                { id: 'completed', name: 'Completed', icon: '‚úÖ' },
                                { id: 'backlog', name: 'Backlog / Someday', icon: 'üì¶' }
                            ],
                            dailyBlocks: [],
                            dailyTemplates: [],
                            currentDate: new Date(),
                            activeCategoryFilter: null,
                            dailyLogs: [],
                            settings: {
                                distractionMessage: "Stay focused on your tasks!",
                                theme: 'light-mode',
                                focusSessionDuration: 25 * 60,
                                dailyGridStartTime: '07:00',
                                dailyGridEndTime: '23:00',
                                dailyGridInterval: 30,
                            },
                            focusMode: {
                                isActive: false,
                                currentTaskId: null,
                                timerInterval: null,
                                timeLeft: 25 * 60,
                                isRunning: false,
                            },
                            productivityChart: null,
                            dailySummaryChart: null,
                        });
                        initApp();
                        showMessageBox("Data Cleared", "All your data has been successfully cleared.");
                    }
                );
            } else {
                // This branch is for internal calls that don't need user confirmation
                // This path is now only used for explicit internal resets, not for load failures.
                localStorage.removeItem('focusBoardAppState');
                Object.assign(appState, {
                    tasks: [],
                    categories: [
                        { id: 'todo', name: 'To-Do', icon: 'üìù' },
                        { id: 'in-progress', name: 'In Progress', icon: 'üöß' },
                        { id: 'completed', name: 'Completed', icon: '‚úÖ' },
                        { id: 'backlog', name: 'Backlog / Someday', icon: 'üì¶' }
                    ],
                    dailyBlocks: [],
                    dailyTemplates: [],
                    currentDate: new Date(),
                    activeCategoryFilter: null,
                    dailyLogs: [],
                    settings: {
                        distractionMessage: "Stay focused on your tasks!",
                        theme: 'light-mode',
                        focusSessionDuration: 25 * 60,
                        dailyGridStartTime: '07:00',
                        dailyGridEndTime: '23:00',
                        dailyGridInterval: 30,
                    },
                    focusMode: {
                        isActive: false,
                        currentTaskId: null,
                        timerInterval: null,
                        timeLeft: 25 * 60,
                        isRunning: false,
                    },
                    productivityChart: null,
                    dailySummaryChart: null,
                });
                initApp();
                // No message box here, as this is for internal reset logic.
            }
        }

        // --- Task Management (Kanban) ---

        /**
         * Adds a new task to the appState or updates an existing one.
         * @param {string|null} taskId - ID of the task to update, or null for new task.
         * @param {string} name - Task name.
         * @param {string} description - Task description.
         * @param {number} duration - Estimated duration in hours.
         * @param {string} category - Task category ID.
         * @param {string} dueDate - The date the task is due (YYYY-MM-DD).
         */
        function saveTask(taskId, name, description, duration, category, dueDate) {
            if (!name) {
                showMessageBox("Input Error", "Task name cannot be empty.");
                return;
            }
            if (isNaN(duration) || duration <= 0) {
                showMessageBox("Input Error", "Estimated duration must be a positive number.");
                return;
            }
            if (!dueDate) {
                 showMessageBox("Input Error", "Due Date cannot be empty.");
                 return;
            }

            if (taskId) {
                // Update existing task
                const taskIndex = appState.tasks.findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                    appState.tasks[taskIndex].name = name;
                    appState.tasks[taskIndex].description = description;
                    appState.tasks[taskIndex].duration = duration;
                    appState.tasks[taskIndex].category = category;
                    appState.tasks[taskIndex].dueDate = dueDate;
                    showMessageBox("Success", "Task updated!");
                }
            } else {
                // Add new task
                const newTask = {
                    id: generateId(),
                    name: name,
                    description: description,
                    duration: duration,
                    category: category,
                    dueDate: dueDate,
                    status: 'todo', // New tasks start as 'todo'
                };
                appState.tasks.push(newTask);
                showMessageBox("Success", "Task added!");
            }
            saveData();
            renderKanbanBoard(); // Only re-render Kanban
            closeModal('add-edit-task-modal');
        }

        /**
         * Updates a task's properties (used for status changes).
         * @param {string} taskId - The ID of the task to update.
         * @param {object} updates - An object containing properties to update.
         */
        function updateTask(taskId, updates) {
            const taskIndex = appState.tasks.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                Object.assign(appState.tasks[taskIndex], updates);
                saveData();
                renderKanbanBoard(); // Re-render Kanban
            }
        }

        /**
         * Deletes a task from the appState.
         * @param {string} taskId - The ID of the task to delete.
         */
        function deleteTask(taskId) {
            showConfirmationBox(
                "Confirm Delete Task",
                "Are you sure you want to delete this task? This cannot be undone.",
                () => {
                    appState.tasks = appState.tasks.filter(t => t.id !== taskId);
                    saveData();
                    renderKanbanBoard();
                    closeModal('task-details-modal');
                    showMessageBox("Success", "Task deleted.");
                }
            );
        }

        /**
         * Renders the list of task groups/categories. (Placeholder, no longer renders UI)
         */
        function renderTaskGroups() {
            // This function is now a placeholder. Its original purpose of rendering
            // task group UI has been removed. The categories array is still used
            // internally for task management and Kanban board counts.
            appState.categories.forEach(category => {
                const categoryTasks = appState.tasks.filter(task => task.category === category.id);
                const completedTasks = categoryTasks.filter(task => task.status === 'completed').length;
                const totalTasks = categoryTasks.length;
                const progress = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
                category.progress = progress;
            });
        }

        // --- Kanban Board ---
        function renderKanbanBoard() {
            // Clear all kanban columns
            kanbanTodo.innerHTML = '';
            kanbanInProgress.innerHTML = '';
            kanbanCompleted.innerHTML = '';
            kanbanBacklog.innerHTML = '';

            // Reset counts
            let todoCount = 0;
            let inProgressCount = 0;
            let completedCount = 0;
            let backlogCount = 0;

            appState.tasks.forEach(task => {
                const taskElement = createTaskElement(task); // Reuse task element creation

                switch (task.category) {
                    case 'todo':
                        kanbanTodo.appendChild(taskElement);
                        todoCount++;
                        break;
                    case 'in-progress':
                        kanbanInProgress.appendChild(taskElement);
                        inProgressCount++;
                        break;
                    case 'completed':
                        kanbanCompleted.appendChild(taskElement);
                        completedCount++;
                        break;
                    case 'backlog':
                        kanbanBacklog.appendChild(taskElement);
                        backlogCount++;
                        break;
                }
            });

            kanbanTodoCount.textContent = todoCount;
            kanbanInProgressCount.textContent = inProgressCount;
            kanbanCompletedCount.textContent = completedCount;
            kanbanBacklogCount.textContent = backlogCount;

            setupKanbanDragAndDrop();
        }

        function setupKanbanDragAndDrop() {
            const columns = document.querySelectorAll('.kanban-column');
            columns.forEach(column => {
                column.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Allow drop
                    column.classList.add('drag-over');
                });

                column.addEventListener('dragleave', (e) => {
                    column.classList.remove('drag-over');
                });

                column.addEventListener('drop', (e) => {
                    e.preventDefault();
                    column.classList.remove('drag-over');
                    const taskId = e.dataTransfer.getData('text/plain');
                    const newCategory = column.dataset.category; // Get target category from column's data-category

                    if (draggedTaskId === taskId && newCategory) {
                        const task = appState.tasks.find(t => t.id === taskId);
                        if (task && task.category !== newCategory) {
                            task.category = newCategory;
                            // Optionally update status based on category change
                            if (newCategory === 'completed') {
                                task.status = 'completed';
                            } else if (newCategory === 'in-progress') {
                                task.status = 'in-progress';
                            } else {
                                task.status = 'todo'; // For todo or backlog
                            }
                            saveData();
                            renderKanbanBoard(); // Re-render the board to reflect change
                        }
                    }
                });
            });
        }

        /**
         * Creates a task DOM element with appropriate styling and data.
         * @param {object} task - The task object.
         * @returns {HTMLElement} The task list item element.
         */
        function createTaskElement(task) {
            const taskItem = document.createElement('div');
            taskItem.className = `task-list-item ${task.status}`;
            taskItem.draggable = true; // Make tasks draggable
            taskItem.dataset.taskId = task.id;

            const dueDateInfo = getDueDateStatus(task.dueDate);
            const dueDateBadge = `<span class="due-date-badge ${dueDateInfo.status}">${dueDateInfo.text}</span>`;

            taskItem.innerHTML = `
                <div class="task-title-row">
                    <div class="task-status-indicator ${task.status}"></div>
                    <span class="font-medium flex-grow">${task.name}</span>
                    ${dueDateBadge}
                </div>
                <div class="task-meta-row">
                    <span class="text-xs text-secondary">${task.duration} hrs</span>
                    <span class="text-xs text-secondary">${appState.categories.find(c => c.id === task.category)?.name || 'Uncategorized'}</span>
                </div>
            `;
            taskItem.addEventListener('click', () => showTaskDetails(task.id));

            // Drag and drop listeners for individual tasks
            taskItem.addEventListener('dragstart', (e) => {
                draggedTaskId = task.id;
                e.dataTransfer.setData('text/plain', task.id);
                e.target.classList.add('opacity-50', 'border-primary');
            });
            taskItem.addEventListener('dragend', (e) => {
                e.target.classList.remove('opacity-50', 'border-primary');
                draggedTaskId = null;
            });

            return taskItem;
        }

        // --- Add/Edit Task Modal (for Kanban tasks) ---
        function openAddEditTaskModal(task = null) {
            if (task) {
                addEditTaskModalTitle.textContent = 'Edit Task';
                taskIdToEditInput.value = task.id;
                taskNameInput.value = task.name;
                taskDescriptionInput.value = task.description;
                taskDurationInput.value = task.duration;
                taskCategorySelect.value = task.category;
                taskDueDateInput.value = task.dueDate;
            } else {
                addEditTaskModalTitle.textContent = 'Add New Task';
                taskIdToEditInput.value = '';
                taskNameInput.value = '';
                taskDescriptionInput.value = '';
                taskDurationInput.value = '1';
                taskCategorySelect.value = 'todo'; // Default category for new tasks
                taskDueDateInput.value = formatDateToYYYYMMDD(new Date()); // Default to today
            }
            addEditTaskModal.classList.add('active');
        }

        // --- Task Details Modal (for Kanban tasks) ---

        /**
         * Shows the task details modal for a given task.
         * @param {string} taskId - The ID of the task to display.
         */
        function showTaskDetails(taskId) {
            const task = appState.tasks.find(t => t.id === taskId);
            if (!task) return;

            detailTaskName.textContent = task.name;
            detailTaskDescription.textContent = task.description || 'N/A';
            detailTaskDuration.textContent = task.duration;
            detailTaskCategory.textContent = appState.categories.find(cat => cat.id === task.category)?.name || 'Uncategorized';
            detailTaskDueDate.textContent = task.dueDate;
            detailTaskStatus.textContent = task.status.charAt(0).toUpperCase() + task.status.slice(1);

            markCompletedBtn.onclick = () => {
                updateTask(task.id, { status: 'completed', category: 'completed' }); // Mark as completed and move to completed category
                showMessageBox("Task Completed!", `"${task.name}" marked as completed!`);
                closeModal('task-details-modal');
            };
            if (task.status === 'completed') {
                markCompletedBtn.disabled = true;
                markCompletedBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                markCompletedBtn.disabled = false;
                markCompletedBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }

            editTaskBtn.onclick = () => {
                closeModal('task-details-modal');
                openAddEditTaskModal(task);
            };

            deleteTaskBtn.onclick = () => deleteTask(task.id);

            taskDetailsModal.classList.add('active');
        }

        // --- Daily Planner (New Features) ---

        const DAILY_BLOCK_COLORS = {
            study: '#3b82f6', // Blue 500
            class: '#a855f7', // Purple 500
            break: '#f59e0b', // Amber 500
            exercise: '#22c55e', // Green 500
            rest: '#64748b', // Slate 500
            other: '#94a3b8' // Slate 400
        };

        /**
         * Renders the daily planning grid, including time labels, grid lines, and blocks.
         */
        function renderDailyGrid() {
            console.log("--- renderDailyGrid START ---");
            console.log("appState.dailyBlocks at renderDailyGrid start:", JSON.parse(JSON.stringify(appState.dailyBlocks)));

            timeLabelsContainer.innerHTML = '';
            dailyGrid.innerHTML = ''; // Clear existing blocks and lines

            const startMinutes = timeToMinutes(appState.settings.dailyGridStartTime);
            const endMinutes = timeToMinutes(appState.settings.dailyGridEndTime);
            const interval = appState.settings.dailyGridInterval; // in minutes
            const slotHeight = 40; // px per slot

            // Render Time Labels
            for (let m = startMinutes; m <= endMinutes; m += interval) {
                const timeLabel = document.createElement('div');
                timeLabel.className = 'time-label-item';
                timeLabel.textContent = minutesToTime(m);
                timeLabelsContainer.appendChild(timeLabel);
            }

            // Render Grid Lines and setup grid rows
            const totalSlots = (endMinutes - startMinutes) / interval;
            dailyGrid.style.gridTemplateRows = `repeat(${totalSlots}, ${slotHeight}px)`;

            for (let i = 0; i <= totalSlots; i++) {
                const gridLine = document.createElement('div');
                gridLine.className = 'grid-line';
                gridLine.style.top = `${i * slotHeight}px`;
                dailyGrid.appendChild(gridLine);
            }

            // Render Daily Blocks
            appState.dailyBlocks.forEach(block => {
                const blockElement = createDailyBlockElement(block);
                dailyGrid.appendChild(blockElement);
            });

            // Add live time indicator
            const existingIndicator = document.getElementById('live-time-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            liveTimeIndicator = document.createElement('div');
            liveTimeIndicator.id = 'live-time-indicator';
            liveTimeIndicator.className = 'live-time-indicator';
            dailyGrid.appendChild(liveTimeIndicator);
            updateLiveTimeIndicator(); // Initial positioning
            console.log("--- renderDailyGrid END ---");
        }

        /**
         * Creates a DOM element for a daily block.
         * @param {object} block - The daily block object.
         * @returns {HTMLElement} The block element.
         */
        function createDailyBlockElement(block) {
            const blockElement = document.createElement('div');
            blockElement.className = 'daily-block';
            blockElement.dataset.blockId = block.id;
            blockElement.style.backgroundColor = DAILY_BLOCK_COLORS[block.type] || DAILY_BLOCK_COLORS.other;

            const startMinutes = timeToMinutes(block.startTime);
            const endMinutes = timeToMinutes(block.endTime);
            const gridStartTimeMinutes = timeToMinutes(appState.settings.dailyGridStartTime);
            const interval = appState.settings.dailyGridInterval;
            const slotHeight = 40;

            const topOffset = ((startMinutes - gridStartTimeMinutes) / interval) * slotHeight;
            const height = ((endMinutes - startMinutes) / interval) * slotHeight;

            blockElement.style.top = `${topOffset}px`;
            blockElement.style.height = `${height}px`;
            blockElement.textContent = `${block.title} (${block.startTime} - ${block.endTime})`;

            blockElement.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent grid click from triggering
                openDailyBlockModal(block);
            });

            return blockElement;
        }

        /**
         * Handles mouse events for creating/editing daily blocks via drag.
         * @param {MouseEvent} e - The mouse event.
         */
        function handleGridInteraction(e) {
            const gridRect = dailyGrid.getBoundingClientRect();
            const y = e.clientY - gridRect.top;
            const startMinutes = timeToMinutes(appState.settings.dailyGridStartTime);
            const interval = appState.settings.dailyGridInterval;
            const slotHeight = 40;

            const clickedSlotIndex = Math.floor(y / slotHeight);
            const clickedTimeMinutes = startMinutes + (clickedSlotIndex * interval);
            const clickedTime = minutesToTime(clickedTimeMinutes);

            if (e.type === 'mousedown') {
                isDragging = true;
                dragStartTime = clickedTime;
                dragStartElement = document.createElement('div');
                dragStartElement.className = 'daily-block selected-start';
                dragStartElement.style.backgroundColor = DAILY_BLOCK_COLORS.other;
                dragStartElement.style.top = `${clickedSlotIndex * slotHeight}px`;
                dragStartElement.style.height = `${slotHeight}px`;
                dragStartElement.textContent = `New Block (${clickedTime})`;
                dailyGrid.appendChild(dragStartElement);

                newBlockTempId = generateId(); // Assign a temporary ID for the new block
                appState.dailyBlocks.push({
                    id: newBlockTempId,
                    title: 'New Block',
                    type: 'other',
                    startTime: clickedTime,
                    endTime: minutesToTime(clickedTimeMinutes + interval),
                    color: DAILY_BLOCK_COLORS.other
                });

            } else if (e.type === 'mousemove' && isDragging) {
                // Update the temporary block's end time and height
                const currentSlotIndex = Math.floor(y / slotHeight);
                let currentEndTimeMinutes = startMinutes + ((currentSlotIndex + 1) * interval);
                if (currentEndTimeMinutes <= timeToMinutes(dragStartTime)) { // Ensure end time is after start time
                    currentEndTimeMinutes = timeToMinutes(dragStartTime) + interval;
                }
                const currentEndTime = minutesToTime(currentEndTimeMinutes);

                const tempBlock = appState.dailyBlocks.find(b => b.id === newBlockTempId);
                if (tempBlock) {
                    tempBlock.endTime = currentEndTime;
                    const newHeight = ((timeToMinutes(tempBlock.endTime) - timeToMinutes(tempBlock.startTime)) / interval) * slotHeight;
                    dragStartElement.style.height = `${Math.max(slotHeight, newHeight)}px`; // Min height of one slot
                    dragStartElement.textContent = `New Block (${tempBlock.startTime} - ${tempBlock.endTime})`;
                }

            } else if (e.type === 'mouseup' && isDragging) {
                isDragging = false;
                if (dragStartElement) {
                    dragStartElement.classList.remove('selected-start');
                    dragStartElement.classList.add('selected-end'); // Indicate selection complete
                }

                const finalBlock = appState.dailyBlocks.find(b => b.id === newBlockTempId);
                if (finalBlock) {
                    // Open modal to finalize the block details
                    openDailyBlockModal(finalBlock);
                }
                dragStartTime = null;
                dragStartElement = null;
                newBlockTempId = null;
            }
        }

        /**
         * Opens the modal for adding or editing a daily block.
         * @param {object|null} block - The block object to edit, or null for a new block.
         * @param {string|null} initialStartTime - Optional initial start time for new block.
         * @param {string|null} initialEndTime - Optional initial end time for new block.
         */
        function openDailyBlockModal(block = null, initialStartTime = null, initialEndTime = null) {
            if (block) {
                dailyBlockModalTitle.textContent = 'Edit Daily Block';
                dailyBlockIdToEditInput.value = block.id;
                dailyBlockTitleInput.value = block.title;
                dailyBlockTypeSelect.value = block.type;
                dailyBlockStartTimeInput.value = block.startTime;
                dailyBlockEndTimeInput.value = block.endTime;
                deleteDailyBlockBtn.classList.remove('hidden');
            } else {
                dailyBlockModalTitle.textContent = 'Add New Block';
                dailyBlockIdToEditInput.value = '';
                dailyBlockTitleInput.value = '';
                dailyBlockTypeSelect.value = 'study';
                dailyBlockStartTimeInput.value = initialStartTime || minutesToTime(timeToMinutes(appState.settings.dailyGridStartTime));
                dailyBlockEndTimeInput.value = initialEndTime || minutesToTime(timeToMinutes(appState.settings.dailyGridStartTime) + appState.settings.dailyGridInterval);
                deleteDailyBlockBtn.classList.add('hidden');
            }
            dailyBlockModal.classList.add('active');
        }

        /**
         * Saves a new or updated daily block.
         */
        function saveDailyBlock() {
            console.log("--- saveDailyBlock START ---");
            console.log("Current dailyBlockIdToEditInput.value:", dailyBlockIdToEditInput.value);
            console.log("appState.dailyBlocks BEFORE modification:", JSON.parse(JSON.stringify(appState.dailyBlocks)));

            const blockId = dailyBlockIdToEditInput.value || null;
            const title = dailyBlockTitleInput.value.trim();
            const type = dailyBlockTypeSelect.value;
            const startTime = dailyBlockStartTimeInput.value;
            const endTime = dailyBlockEndTimeInput.value;

            if (!title || !startTime || !endTime) {
                showMessageBox("Input Error", "All fields are required for a daily block.");
                console.log("--- saveDailyBlock END (Input Error) ---");
                return;
            }

            if (timeToMinutes(startTime) >= timeToMinutes(endTime)) {
                showMessageBox("Input Error", "End time must be after start time.");
                console.log("--- saveDailyBlock END (Time Error) ---");
                return;
            }

            if (blockId) {
                const blockIndex = appState.dailyBlocks.findIndex(b => b.id === blockId);
                if (blockIndex !== -1) {
                    Object.assign(appState.dailyBlocks[blockIndex], { title, type, startTime, endTime, color: DAILY_BLOCK_COLORS[type] || DAILY_BLOCK_COLORS.other });
                    showMessageBox("Success", "Daily block updated!");
                } else {
                    // This case should ideally not happen if IDs are unique and blocks are managed correctly.
                    // If it does, it means we're trying to update a block that doesn't exist in appState.
                    console.warn("Attempted to update a daily block with ID that was not found:", blockId);
                    const newBlock = { // Treat as new block if ID not found
                        id: generateId(),
                        title,
                        type,
                        startTime,
                        endTime,
                        color: DAILY_BLOCK_COLORS[type] || DAILY_BLOCK_COLORS.other
                    };
                    appState.dailyBlocks.push(newBlock);
                    showMessageBox("Success", "Daily block added (ID not found, treated as new)!");
                }
            } else {
                const newBlock = {
                    id: generateId(),
                    title,
                    type,
                    startTime,
                    endTime,
                    color: DAILY_BLOCK_COLORS[type] || DAILY_BLOCK_COLORS.other
                };
                appState.dailyBlocks.push(newBlock);
                showMessageBox("Success", "Daily block added!");
            }
            console.log("appState.dailyBlocks AFTER modification (before saveData):", JSON.parse(JSON.stringify(appState.dailyBlocks)));
            saveData();
            console.log("appState.dailyBlocks AFTER saveData:", JSON.parse(JSON.stringify(appState.dailyBlocks)));
            renderDailyGrid();
            console.log("renderDailyGrid called. appState.dailyBlocks should be reflected on UI now.");
            closeModal('daily-block-modal');
            setAllBlockReminders(); // Re-set reminders after changes
            console.log("--- saveDailyBlock END ---");
        }

        /**
         * Deletes a daily block.
         * @param {string} blockId - The ID of the block to delete.
         */
        function deleteDailyBlock(blockId) {
            showConfirmationBox(
                "Confirm Delete Block",
                "Are you sure you want to delete this daily block? This cannot be undone.",
                () => {
                    appState.dailyBlocks = appState.dailyBlocks.filter(b => b.id !== blockId);
                    saveData();
                    renderDailyGrid();
                    renderDailySummaryChart();
                    closeModal('daily-block-modal');
                    showMessageBox("Success", "Daily block deleted.");
                    setAllBlockReminders(); // Re-set reminders after deletion
                }
            );
        }

        /**
         * Saves the current daily plan as a template.
         */
        function saveDailyTemplate() {
            const templateName = prompt("Enter a name for this daily plan template:");
            if (templateName && templateName.trim() !== "") {
                const newTemplate = {
                    id: generateId(),
                    name: templateName.trim(),
                    blocks: JSON.parse(JSON.stringify(appState.dailyBlocks)) // Deep copy
                };
                appState.dailyTemplates.push(newTemplate);
                saveData();
                showMessageBox("Template Saved", `Template "${newTemplate.name}" saved successfully!`);
            } else {
                showMessageBox("Input Required", "Template name cannot be empty.");
            }
        }

        /**
         * Loads a selected daily plan template.
         */
        function loadDailyTemplate() {
            templateListContainer.innerHTML = '';
            if (appState.dailyTemplates.length === 0) {
                templateListContainer.innerHTML = '<p class="text-sm text-secondary">No templates saved yet.</p>';
                loadSelectedTemplateBtn.disabled = true;
            } else {
                loadSelectedTemplateBtn.disabled = false;
                appState.dailyTemplates.forEach(template => {
                    const templateItem = document.createElement('label');
                    templateItem.className = 'flex items-center space-x-2 p-2 hover:bg-gray-700 rounded-md cursor-pointer';
                    templateItem.innerHTML = `
                        <input type="radio" name="selectedTemplate" value="${template.id}" class="form-radio text-primary">
                        <span>${template.name} (${template.blocks.length} blocks)</span>
                    `;
                    templateListContainer.appendChild(templateItem);
                });
            }
            templateSelectionModal.classList.add('active');
        }

        /**
         * Clears all daily blocks for the current day.
         */
        function clearDailyPlan() {
            showConfirmationBox(
                "Confirm Clear Daily Plan",
                "Are you sure you want to clear all blocks for today's plan?",
                () => {
                    appState.dailyBlocks = [];
                    saveData();
                    renderDailyGrid();
                    renderDailySummaryChart();
                    showMessageBox("Plan Cleared", "Today's daily plan has been cleared.");
                    setAllBlockReminders(); // Clear existing timers
                }
            );
        }

        /**
         * Updates the position of the live time indicator.
         */
        let liveTimeIndicatorInterval = null;
        function updateLiveTimeIndicator() {
            const now = new Date();
            const currentMinutes = now.getHours() * 60 + now.getMinutes();
            const startMinutes = timeToMinutes(appState.settings.dailyGridStartTime);
            const endMinutes = timeToMinutes(appState.settings.dailyGridEndTime);
            const interval = appState.settings.dailyGridInterval;
            const slotHeight = 40;

            if (currentMinutes < startMinutes || currentMinutes > endMinutes) {
                liveTimeIndicator.style.display = 'none'; // Hide if outside grid hours
                return;
            } else {
                liveTimeIndicator.style.display = 'block';
            }

            const totalGridMinutes = endMinutes - startMinutes;
            const minutesIntoGrid = currentMinutes - startMinutes;
            const percentageThroughGrid = minutesIntoGrid / totalGridMinutes;
            const totalGridHeight = (totalGridMinutes / interval) * slotHeight;

            liveTimeIndicator.style.top = `${percentageThroughGrid * totalGridHeight}px`;

            // Clear previous interval and set a new one for smoother movement
            if (liveTimeIndicatorInterval) {
                clearInterval(liveTimeIndicatorInterval);
            }
            // Update every minute for smoother line movement
            liveTimeIndicatorInterval = setInterval(updateLiveTimeIndicator, 60 * 1000);
        }

        /**
         * Sets a reminder for a given daily block.
         * @param {object} block - The daily block object.
         */
        function setBlockReminder(block) {
            const now = new Date();
            const blockStartTime = new Date();
            const [startH, startM] = block.startTime.split(':').map(Number);
            blockStartTime.setHours(startH, startM, 0, 0);

            const timeToReminder = blockStartTime.getTime() - now.getTime();

            if (timeToReminder > 0) {
                setTimeout(() => {
                    showMessageBox("Time for your block!", `It's time for: ${block.title}`);
                }, timeToReminder);
            }
        }

        /**
         * Sets reminders for all daily blocks.
         */
        function setAllBlockReminders() {
            // Clear any existing reminders first to prevent duplicates
            // (This would require storing setTimeout IDs, for simplicity, we'll just let old ones run or be GC'd)
            // For a robust solution, store setTimeout IDs and clear them here.
            appState.dailyBlocks.forEach(block => {
                setBlockReminder(block);
            });
        }


        // --- Daily Reflection ---

        /**
         * Shows the daily reflection modal.
         */
        function showReflectionModal() {
            reflectionTasksList.innerHTML = '';
            const today = formatDateToYYYYMMDD(new Date());
            const tasksForReflection = appState.tasks.filter(task => task.dueDate === today);

            if (tasksForReflection.length === 0) {
                reflectionTasksList.innerHTML = '<p class="text-sm text-secondary">No tasks for today to reflect on.</p>';
            } else {
                tasksForReflection.forEach(task => {
                    const taskCheckboxDiv = document.createElement('div');
                    taskCheckboxDiv.className = 'flex items-center';
                    taskCheckboxDiv.innerHTML = `
                        <input type="checkbox" id="reflection-task-${task.id}" data-task-id="${task.id}"
                               class="w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 dark:focus:ring-indigo-600 dark:ring-offset-gray-800 dark:bg-gray-700 dark:border-gray-600"
                               ${task.status === 'completed' ? 'checked' : ''}>
                        <label for="reflection-task-${task.id}" class="ms-2 text-sm font-medium text-gray-900 dark:text-gray-300">${task.name}</label>
                    `;
                    reflectionTasksList.appendChild(taskCheckboxDiv);
                });
            }

            distractionInput.value = '';
            moodRatingInput.value = '';
            document.querySelectorAll('#reflection-modal .text-4xl span').forEach(span => {
                span.addEventListener('click', (e) => {
                    document.querySelectorAll('#reflection-modal .text-4xl span').forEach(s => s.classList.remove('scale-125'));
                    e.target.classList.add('scale-125');
                    moodRatingInput.value = e.target.dataset.mood;
                });
            });

            reflectionModal.classList.add('active');
        }

        /**
         * Submits the daily reflection data.
         */
        function submitReflection() {
            const completedTaskIds = Array.from(reflectionTasksList.querySelectorAll('input[type="checkbox"]:checked'))
                                       .map(checkbox => checkbox.dataset.taskId);
            const distractions = distractionInput.value.trim();
            const mood = moodRatingInput.value;

            if (!mood) {
                showMessageBox("Input Error", "Please select your mood for today.");
                return;
            }

            const today = formatDateToYYYYMMDD(new Date());
            const tasksForReflection = appState.tasks.filter(task => task.dueDate === today);

            const totalTasksForReflection = tasksForReflection.length;
            const totalCompletedInReflection = completedTaskIds.length;
            const productivityScore = totalTasksForReflection > 0 ? Math.round((totalCompletedInReflection / totalTasksForReflection) * 100) : 0;

            const newLog = {
                date: today,
                productivityScore: productivityScore,
                distractions: distractions,
                mood: mood,
                completedTasks: completedTaskIds
            };

            // Update status of tasks marked completed in reflection
            completedTaskIds.forEach(taskId => {
                const task = appState.tasks.find(t => t.id === taskId);
                if (task && task.status !== 'completed') {
                    task.status = 'completed';
                    task.category = 'completed'; // Also move to completed category
                }
            });

            appState.dailyLogs = appState.dailyLogs.filter(log => log.date !== today);
            appState.dailyLogs.push(newLog);
            saveData();
            renderDailyLogSummary();
            renderKanbanBoard(); // Only re-render Kanban
            closeModal('reflection-modal');
            showMessageBox("Reflection Saved", `Your productivity score for today: ${productivityScore}%`);
        }

        /**
         * Renders a summary of the last daily log.
         */
        function renderDailyLogSummary() {
            const lastLog = appState.dailyLogs[appState.dailyLogs.length - 1];
            if (lastLog) {
                dailyLogSummary.innerHTML = `
                    <p class="font-semibold">Last Reflection (${lastLog.date}):</p>
                    <p>Productivity: <span class="font-bold text-primary">${lastLog.productivityScore}%</span></p>
                    <p>Mood: ${lastLog.mood}</p>
                    <p>Distractions: ${lastLog.distractions || 'None recorded'}</p>
                `;
            } else {
                dailyLogSummary.innerHTML = '<p class="text-sm text-secondary">No reflections yet. Reflect on your day to see insights!</p>';
            }
        }

        // --- Settings ---

        /**
         * Shows the settings modal and populates inputs.
         */
        function showSettings() {
            customReminderMessageInput.value = appState.settings.distractionMessage;
            focusDurationInput.value = appState.settings.focusSessionDuration / 60; // Convert seconds to minutes
            gridStartTimeInput.value = appState.settings.dailyGridStartTime;
            gridEndTimeInput.value = appState.settings.dailyGridEndTime;
            gridIntervalSelect.value = appState.settings.dailyGridInterval;
            settingsModal.classList.add('active');
        }

        /**
         * Saves settings from the modal inputs.
         */
        function saveSettings() {
            const newDistractionMessage = customReminderMessageInput.value.trim();
            const newFocusDuration = parseInt(focusDurationInput.value) * 60; // Convert minutes to seconds
            const newGridStartTime = gridStartTimeInput.value;
            const newGridEndTime = gridEndTimeInput.value;
            const newGridInterval = parseInt(gridIntervalSelect.value);

            if (timeToMinutes(newGridStartTime) >= timeToMinutes(newGridEndTime)) {
                showMessageBox("Input Error", "Grid end time must be after start time.");
                return;
            }
            if (newFocusDuration <= 0) {
                showMessageBox("Input Error", "Focus duration must be a positive number.");
                return;
            }

            appState.settings.distractionMessage = newDistractionMessage;
            appState.settings.focusSessionDuration = newFocusDuration;
            appState.settings.dailyGridStartTime = newGridStartTime;
            appState.settings.dailyGridEndTime = newGridEndTime;
            appState.settings.dailyGridInterval = newGridInterval;

            // Update focus mode timeLeft if it's not running
            if (!appState.focusMode.isRunning) {
                appState.focusMode.timeLeft = appState.settings.focusSessionDuration;
                updateFocusTimerDisplay();
            }

            saveData();
            closeModal('settings-modal');
            renderDailyGrid(); // Re-render grid with new settings
            showMessageBox("Settings Saved", "Your preferences have been updated.");
        }

        /**
         * Exports appState as a JSON file.
         */
        function exportData() {
            const dataStr = JSON.stringify(appState, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `focusboard_backup_${formatDateToYYYYMMDD(new Date())}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("Data Exported", "Your data has been exported as a JSON file.");
        }

        // --- Theme Toggling ---

        /**
         * Toggles between light and dark mode.
         */
        function toggleTheme() {
            appState.settings = appState.settings || {};
            appState.settings.theme = appState.settings.theme || 'light-mode';

            if (body.classList.contains('light-mode')) {
                body.classList.remove('light-mode');
                body.classList.add('dark-mode');
                appState.settings.theme = 'dark-mode';
                themeIconPath.setAttribute('d', 'M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9 9 0 008.354-5.646z');
            } else {
                body.classList.remove('dark-mode');
                body.classList.add('light-mode');
                appState.settings.theme = 'light-mode';
                themeIconPath.setAttribute('d', 'M12 3v1m0 16v1m9-9h1M4 12H3m15.325 5.325l-.707.707M6.364 6.364l-.707-.707M17.657 6.343l.707-.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z');
            }
            saveData();
        }

        /**
         * Applies the saved theme on load.
         */
        function applyTheme() {
            if (appState.settings && typeof appState.settings.theme !== 'undefined') {
                if (appState.settings.theme === 'dark-mode') {
                    body.classList.remove('light-mode');
                    body.classList.add('dark-mode');
                    themeIconPath.setAttribute('d', 'M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9 9 0 008.354-5.646z');
                } else {
                    body.classList.remove('dark-mode');
                    body.classList.add('light-mode');
                    themeIconPath.setAttribute('d', 'M12 3v1m0 16v1m9-9h1M4 12H3m15.325 5.325l-.707.707M6.364 6.364l-.707-.707M17.657 6.343l.707-.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z');
                }
            } else {
                console.warn("appState.settings or appState.settings.theme is undefined or invalid. Defaulting to light-mode.");
                body.classList.add('light-mode');
                appState.settings = appState.settings || {};
                appState.settings.theme = 'light-mode';
                themeIconPath.setAttribute('d', 'M12 3v1m0 16v1m9-9h1M4 12H3m15.325 5.325l-.707.707M6.364 6.364l-.707-.707M17.657 6.343l.707-.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z');
            }
            saveData();
        }

        // --- Tab Functionality ---
        function setupTabs() {
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.dataset.tab;

                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        // Force reflow to restart animation if tab is re-activated quickly
                        void content.offsetWidth;
                    });

                    button.classList.add('active');
                    const activeTabContent = document.getElementById(`${targetTab}-tab`);
                    activeTabContent.classList.add('active');


                    // Re-render relevant sections when a tab is activated
                    renderAll(); // Call renderAll to ensure all relevant sections are updated
                });
            });
        }

        // --- Daily Summary Chart (Chart.js Pie Chart) ---
        function renderDailySummaryChart() {
            if (appState.dailySummaryChart) {
                appState.dailySummaryChart.destroy(); // Destroy existing chart if it exists
            }

            const typeDurations = {}; // { type: totalMinutes }
            let totalPlannedMinutes = 0;

            appState.dailyBlocks.forEach(block => {
                const durationMinutes = timeToMinutes(block.endTime) - timeToMinutes(block.startTime);
                typeDurations[block.type] = (typeDurations[block.type] || 0) + durationMinutes;
                totalPlannedMinutes += durationMinutes;
            });

            const labels = Object.keys(typeDurations).map(type => {
                const emoji = {
                    study: 'üìò', class: 'üßë‚Äçüè´', break: 'üçΩÔ∏è', exercise: 'üèãÔ∏è', rest: 'üí§', other: ''
                }[type] || '';
                return `${emoji} ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            });
            const data = Object.values(typeDurations);

            // Define colors for the pie chart slices
            const backgroundColors = labels.map(label => {
                const type = label.split(' ')[1]?.toLowerCase() || 'other'; // Extract type from label
                return DAILY_BLOCK_COLORS[type] || DAILY_BLOCK_COLORS.other;
            });

            // Calculate total available minutes in the grid
            const gridStartMinutes = timeToMinutes(appState.settings.dailyGridStartTime);
            const gridEndMinutes = timeToMinutes(appState.settings.dailyGridEndTime);
            const totalAvailableGridMinutes = gridEndMinutes - gridStartMinutes;

            // Add "Unplanned Time" if there's a difference
            let unplannedMinutes = totalAvailableGridMinutes - totalPlannedMinutes;
            if (unplannedMinutes < 0) unplannedMinutes = 0; // Should not be negative

            if (unplannedMinutes > 0) {
                labels.push('Unplanned Time');
                data.push(unplannedMinutes);
                backgroundColors.push('#4b5563'); // Muted color for unplanned
            }

            const ctx = dailySummaryChartCanvas.getContext('2d');
            appState.dailySummaryChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: getComputedStyle(document.body).getPropertyValue('--text-light'),
                                font: {
                                    size: 14
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: 'Daily Time Allocation',
                            color: getComputedStyle(document.body).getPropertyValue('--text-light'),
                            font: {
                                size: 18
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw;
                                    const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    const hours = Math.floor(value / 60);
                                    const minutes = value % 60;
                                    return `${label}: ${hours}h ${minutes}m (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // --- Focus Mode ---
        function toggleFocusMode(activate, taskId = null) {
            appState.focusMode.isActive = activate;
            if (activate) {
                focusModeOverlay.classList.add('active');
                appState.focusMode.currentTaskId = taskId;
                if (taskId) {
                    const task = appState.tasks.find(t => t.id === taskId);
                    if (task) {
                        focusTaskName.textContent = task.name;
                        focusTaskDescription.textContent = task.description || 'No description provided.';
                        // Basic checklist from description (simple lines starting with - or *)
                        focusChecklistItems.innerHTML = '';
                        if (task.description) {
                            const lines = task.description.split('\n').filter(line => line.startsWith('- ') || line.startsWith('* '));
                            if (lines.length > 0) {
                                lines.forEach((line, index) => {
                                    const itemText = line.substring(2).trim();
                                    const checkboxId = `focus-checklist-${task.id}-${index}`;
                                    const checklistItem = document.createElement('div');
                                    checklistItem.className = 'focus-checklist-item';
                                    checklistItem.innerHTML = `
                                        <input type="checkbox" id="${checkboxId}" class="rounded text-indigo-600">
                                        <label for="${checkboxId}">${itemText}</label>
                                    `;
                                    focusChecklistItems.appendChild(checklistItem);
                                });
                            } else {
                                focusChecklistItems.innerHTML = '<p class="text-sm text-muted">No checklist items found in description.</p>';
                            }
                        } else {
                            focusChecklistItems.innerHTML = '<p class="text-sm text-muted">No checklist items found in description.</p>';
                        }

                        // Initialize timer for this task
                        appState.focusMode.timeLeft = appState.settings.focusSessionDuration;
                        updateFocusTimerDisplay();
                        startFocusTimer(); // Auto-start timer when entering focus mode
                    }
                } else {
                    focusTaskName.textContent = "No task selected for focus.";
                    focusTaskDescription.textContent = "Select a task from your board to focus on it.";
                    focusChecklistItems.innerHTML = '';
                    appState.focusMode.timeLeft = appState.settings.focusSessionDuration;
                    updateFocusTimerDisplay();
                    stopFocusTimer(); // Ensure timer is stopped if no task is selected
                }
                // Hide main content for full-screen effect
                document.querySelector('main').style.display = 'none';
                document.querySelector('header').style.display = 'none';
                document.querySelector('.tab-buttons').style.display = 'none';
            } else {
                focusModeOverlay.classList.remove('active');
                stopFocusTimer(); // Stop timer when exiting focus mode
                // Show main content again
                document.querySelector('main').style.display = 'flex';
                document.querySelector('header').style.display = 'flex';
                // Re-evaluate tab-buttons display based on screen size
                if (window.innerWidth < 1024) {
                    document.querySelector('.tab-buttons').style.display = 'flex';
                }
            }
            saveData();
        }

        function updateFocusTimerDisplay() {
            // Ensure appState.focusMode and appState.focusMode.timeLeft exist
            const timeLeft = appState.focusMode && appState.focusMode.timeLeft !== undefined
                             ? appState.focusMode.timeLeft
                             : appState.settings.focusSessionDuration; // Fallback to default session duration

            focusTimerDisplay.textContent = formatTime(timeLeft);
        }

        function startFocusTimer() {
            if (appState.focusMode.isRunning) return;
            appState.focusMode.isRunning = true;
            focusStartBtn.textContent = 'Resume';
            ambientSoundPlayer.play().catch(e => console.error("Error playing ambient sound:", e)); // Play sound

            appState.focusMode.timerInterval = setInterval(() => {
                appState.focusMode.timeLeft--;
                updateFocusTimerDisplay();

                if (appState.focusMode.timeLeft <= 0) {
                    stopFocusTimer();
                    ambientSoundPlayer.pause();
                    ambientSoundPlayer.currentTime = 0;
                    showMessageBox("Focus Session Complete!", "Great job! Time for a break or next task.");
                    // Optionally mark task as in-progress or completed if focus session ends
                    if (appState.focusMode.currentTaskId) {
                        const task = appState.tasks.find(t => t.id === appState.focusMode.currentTaskId);
                        if (task && task.status === 'todo') {
                            updateTask(task.id, { status: 'in-progress', category: 'in-progress' });
                        }
                    }
                    resetFocusTimer(); // Reset for next session
                }
            }, 1000);
            saveData();
        }

        function pauseFocusTimer() {
            if (!appState.focusMode.isRunning) return;
            clearInterval(appState.focusMode.timerInterval);
            appState.focusMode.timerInterval = null;
            appState.focusMode.isRunning = false;
            focusStartBtn.textContent = 'Start';
            ambientSoundPlayer.pause(); // Pause sound
            saveData();
        }

        function stopFocusTimer() {
            clearInterval(appState.focusMode.timerInterval);
            appState.focusMode.timerInterval = null;
            appState.focusMode.isRunning = false;
            focusStartBtn.textContent = 'Start';
            ambientSoundPlayer.pause();
            ambientSoundPlayer.currentTime = 0;
            saveData();
        }

        function resetFocusTimer() {
            stopFocusTimer();
            appState.focusMode.timeLeft = appState.settings.focusSessionDuration;
            appState.focusMode.isRunning = false;
            focusStartBtn.textContent = 'Start';
            updateFocusTimerDisplay();
            ambientSoundPlayer.pause();
            ambientSoundPlayer.currentTime = 0;
            saveData();
        }

        function completeFocusTask() {
            if (appState.focusMode.currentTaskId) {
                updateTask(appState.focusMode.currentTaskId, { status: 'completed', category: 'completed' });
                showMessageBox("Task Completed!", "You finished your focused task!");
                toggleFocusMode(false); // Exit focus mode
            } else {
                showMessageBox("No Task Selected", "Please select a task to mark as completed.");
            }
        }

        function toggleAmbientSound() {
            if (ambientSoundPlayer.paused) {
                ambientSoundPlayer.play().catch(e => console.error("Error playing ambient sound:", e));
            } else {
                ambientSoundPlayer.pause();
            }
        }

        // --- Smart Suggestions (Lite Version) ---
        const predefinedSuggestions = ["Study", "Meeting", "Exercise", "Read Book", "Write Report", "Grocery Shopping", "Clean Room", "Call Mom", "Project Work", "Review Code"];

        function showSuggestions() {
            const input = taskNameInput.value.toLowerCase();
            suggestionBox.innerHTML = '';
            suggestionBox.classList.add('hidden');

            if (input.length === 0) return;

            const matches = predefinedSuggestions.filter(s => s.toLowerCase().includes(input));

            if (matches.length > 0) {
                matches.forEach(match => {
                    const div = document.createElement('div');
                    div.textContent = match;
                    div.className = 'p-2 cursor-pointer hover:bg-gray-700 dark:hover:bg-gray-600 rounded-md';
                    div.addEventListener('click', () => {
                        taskNameInput.value = match;
                        suggestionBox.classList.add('hidden');
                    });
                    suggestionBox.appendChild(div);
                });
                suggestionBox.classList.remove('hidden');
            }
        }

        // --- Focus Reminder AI (Lite Version) ---
        const motivationalQuotes = [
            "The best way to predict the future is to create it.",
            "Success is not final, failure is not fatal: it is the courage to continue that counts.",
            "The only way to do great work is to love what you do.",
            "Believe you can and you're halfway there.",
            "The mind is everything. What you think you become.",
            "Are you working on your most important task?",
            "Stay focused. You‚Äôre doing great.",
            "What is one small step you can take right now?",
            "Don't let distractions win. Your goals are waiting."
        ];
        let currentReminderIndex = 0;

        function showFocusReminder() {
            const message = appState.settings.distractionMessage || motivationalQuotes[currentReminderIndex];
            showMessageBox("Focus Reminder", message);
            currentReminderIndex = (currentReminderIndex + 1) % motivationalQuotes.length;
        }

        // --- Loader Functions ---
        function showLoader() {
            loaderOverlay.classList.add('active');
        }

        function hideLoader() {
            loaderOverlay.classList.remove('active');
        }

        // --- Initialization and Event Listeners ---

        /**
         * Renders all major UI components based on the active tab or desktop layout.
         */
        function renderAll() {
            applyTheme(); // Always apply theme first

            // Determine active tab for mobile or render all for desktop
            const activeTabButton = document.querySelector('.tab-button.active');
            if (window.innerWidth >= 1024) { // Desktop view: render all columns
                document.getElementById('kanban-tab').style.display = 'flex';
                document.getElementById('daily-planner-tab').style.display = 'flex';
                document.getElementById('reflection-tab').style.display = 'flex';

                renderKanbanBoard();
                renderDailyGrid();
                renderDailySummaryChart();
                renderDailyLogSummary();
            } else if (activeTabButton) { // Mobile/Tablet view: render only active tab
                const activeTabId = activeTabButton.dataset.tab;
                tabContents.forEach(content => content.style.display = 'none'); // Hide all first
                document.getElementById(`${activeTabId}-tab`).style.display = 'flex'; // Show active

                if (activeTabId === 'kanban') {
                    renderKanbanBoard();
                } else if (activeTabId === 'daily-planner') {
                    renderDailyGrid();
                    renderDailySummaryChart();
                } else if (activeTabId === 'reflection') {
                    renderDailyLogSummary();
                }
            } else { // Fallback if no active tab button found (e.g., first load on mobile before default active is set)
                // Default to kanban tab
                document.getElementById('kanban-tab').classList.add('active');
                document.querySelector('.tab-button[data-tab="kanban"]').classList.add('active');
                renderKanbanBoard();
            }
        }

        /**
         * Sets up all event listeners for the application.
         */
        function setupEventListeners() {
            addKanbanTaskBtn.addEventListener('click', () => openAddEditTaskModal());

            saveTaskBtn.addEventListener('click', () => {
                const taskId = taskIdToEditInput.value || null;
                const name = taskNameInput.value.trim();
                const description = taskDescriptionInput.value.trim();
                const duration = parseFloat(taskDurationInput.value);
                const category = taskCategorySelect.value;
                const dueDate = taskDueDateInput.value;
                saveTask(taskId, name, description, duration, category, dueDate);
            });

            taskNameInput.addEventListener('input', showSuggestions);
            taskNameInput.addEventListener('blur', () => {
                setTimeout(() => suggestionBox.classList.add('hidden'), 200);
            });
            taskNameInput.addEventListener('focus', showSuggestions);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    if (document.activeElement === taskNameInput) {
                        e.preventDefault();
                        saveTaskBtn.click();
                    }
                } else if (e.ctrlKey && e.key === 'Enter') {
                    if (taskDetailsModal.classList.contains('active') && !markCompletedBtn.disabled) {
                        markCompletedBtn.click();
                    } else if (focusModeOverlay.classList.contains('active')) {
                        focusCompleteBtn.click();
                    }
                }
            });

            startReflectionBtn.addEventListener('click', showReflectionModal);
            submitReflectionBtn.addEventListener('click', submitReflection);

            document.querySelectorAll('#reflection-modal .text-4xl span').forEach(span => {
                span.addEventListener('click', (e) => {
                    document.querySelectorAll('#reflection-modal .text-4xl span').forEach(s => s.classList.remove('scale-125'));
                    e.target.classList.add('scale-125');
                    moodRatingInput.value = e.target.dataset.mood;
                });
            });

            showSettingsBtn.addEventListener('click', showSettings);
            saveSettingsBtn.addEventListener('click', saveSettings);
            exportDataBtn.addEventListener('click', exportData);
            clearAllDataBtn.addEventListener('click', () => clearAllData(true));

            themeToggleBtn.addEventListener('click', toggleTheme);

            // Attach event listeners for all modal close buttons
            document.querySelectorAll('.modal-close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const modalId = e.target.dataset.modalId;
                    if (modalId) {
                        closeModal(modalId);
                    }
                });
            });

            openFocusModeBtn.addEventListener('click', () => toggleFocusMode(true, appState.focusMode.currentTaskId));
            focusStartBtn.addEventListener('click', startFocusTimer);
            focusPauseBtn.addEventListener('click', pauseFocusTimer);
            focusResetBtn.addEventListener('click', resetFocusTimer);
            focusCompleteBtn.addEventListener('click', completeFocusTask);
            toggleAmbientSoundBtn.addEventListener('click', toggleAmbientSound);
            focusModeCloseBtn.addEventListener('click', () => toggleFocusMode(false));

            // Daily Planner Event Listeners
            dailyGrid.addEventListener('mousedown', handleGridInteraction);
            dailyGrid.addEventListener('mousemove', handleGridInteraction);
            dailyGrid.addEventListener('mouseup', handleGridInteraction);

            saveDailyBlockBtn.addEventListener('click', saveDailyBlock);
            deleteDailyBlockBtn.addEventListener('click', () => deleteDailyBlock(dailyBlockIdToEditInput.value));

            saveTemplateBtn.addEventListener('click', saveDailyTemplate);
            loadTemplateBtn.addEventListener('click', loadDailyTemplate);
            clearDailyPlanBtn.addEventListener('click', clearDailyPlan);

            loadSelectedTemplateBtn.addEventListener('click', () => {
                const selectedTemplateId = document.querySelector('input[name="selectedTemplate"]:checked')?.value;
                if (selectedTemplateId) {
                    const template = appState.dailyTemplates.find(t => t.id === selectedTemplateId);
                    if (template) {
                        appState.dailyBlocks = JSON.parse(JSON.stringify(template.blocks)); // Deep copy
                        saveData();
                        renderDailyGrid();
                        renderDailySummaryChart();
                        closeModal('template-selection-modal');
                        showMessageBox("Template Loaded", `Template "${template.name}" loaded successfully!`);
                        setAllBlockReminders();
                    }
                } else {
                    showMessageBox("No Template Selected", "Please select a template to load.");
                }
            });
        }

        /**
         * Initializes the application.
         */
        function initApp() {
            // Assign loader element first
            loaderOverlay = document.getElementById('loader-overlay');
            showLoader(); // Show loader at the very beginning of initialization

            // Assign other DOM elements
            themeToggleBtn = document.getElementById('theme-toggle');
            themeIconPath = document.getElementById('theme-icon-path');
            body = document.body;

            addKanbanTaskBtn = document.getElementById('add-task-kanban-btn');

            dailyPlannerTab = document.getElementById('daily-planner-tab');
            saveTemplateBtn = document.getElementById('save-template-btn');
            loadTemplateBtn = document.getElementById('load-template-btn');
            clearDailyPlanBtn = document.getElementById('clear-daily-plan-btn');
            timeLabelsContainer = document.getElementById('time-labels');
            dailyGridContainer = document.querySelector('.daily-grid-container');
            dailyGrid = document.getElementById('daily-grid');
            liveTimeIndicator = document.getElementById('live-time-indicator');
            dailySummaryChartCanvas = document.getElementById('daily-summary-chart');

            startReflectionBtn = document.getElementById('start-reflection-btn');
            dailyLogSummary = document.getElementById('daily-log-summary');

            addEditTaskModal = document.getElementById('add-edit-task-modal');
            addEditTaskModalTitle = document.getElementById('add-edit-task-modal-title');
            taskIdToEditInput = document.getElementById('task-id-to-edit');
            taskNameInput = document.getElementById('task-name-input');
            taskDescriptionInput = document.getElementById('task-description-input');
            taskDurationInput = document.getElementById('task-duration-input');
            taskCategorySelect = document.getElementById('task-category-select');
            taskDueDateInput = document.getElementById('task-due-date-input');
            saveTaskBtn = document.getElementById('save-task-btn');
            suggestionBox = document.getElementById('suggestion-box');

            taskDetailsModal = document.getElementById('task-details-modal');
            detailTaskName = document.getElementById('detail-task-name');
            detailTaskDescription = document.getElementById('detail-task-description');
            detailTaskDuration = document.getElementById('detail-task-duration');
            detailTaskCategory = document.getElementById('detail-task-category');
            detailTaskDueDate = document.getElementById('detail-task-due-date');
            detailTaskStatus = document.getElementById('detail-task-status');
            markCompletedBtn = document.getElementById('mark-completed-btn');
            editTaskBtn = document.getElementById('edit-task-btn');
            deleteTaskBtn = document.getElementById('delete-task-btn');

            dailyBlockModal = document.getElementById('daily-block-modal');
            dailyBlockModalTitle = document.getElementById('daily-block-modal-title');
            dailyBlockIdToEditInput = document.getElementById('daily-block-id-to-edit');
            dailyBlockTitleInput = document.getElementById('daily-block-title-input');
            dailyBlockTypeSelect = document.getElementById('daily-block-type-select');
            dailyBlockStartTimeInput = document.getElementById('daily-block-start-time-input');
            dailyBlockEndTimeInput = document.getElementById('daily-block-end-time-input');
            saveDailyBlockBtn = document.getElementById('save-daily-block-btn');
            deleteDailyBlockBtn = document.getElementById('delete-daily-block-btn');

            reflectionModal = document.getElementById('reflection-modal');
            reflectionTasksList = document.getElementById('reflection-tasks-list');
            distractionInput = document.getElementById('distraction-input');
            moodRatingInput = document.getElementById('mood-rating');
            submitReflectionBtn = document.getElementById('submit-reflection-btn');

            settingsModal = document.getElementById('settings-modal');
            showSettingsBtn = document.getElementById('show-settings-btn');
            saveSettingsBtn = document.getElementById('save-settings-btn');
            customReminderMessageInput = document.getElementById('distraction-message-input');
            focusDurationInput = document.getElementById('focus-duration-input');
            gridStartTimeInput = document.getElementById('grid-start-time-input');
            gridEndTimeInput = document.getElementById('grid-end-time-input');
            gridIntervalSelect = document.getElementById('grid-interval-select');
            exportDataBtn = document.getElementById('export-data-btn');
            clearAllDataBtn = document.getElementById('clear-all-data-btn');

            messageBoxModal = document.getElementById('message-box-modal');
            messageBoxTitle = document.getElementById('message-box-title');
            messageBoxText = document.getElementById('message-box-text');
            messageBoxOkBtn = document.getElementById('message-box-ok-btn');
            messageBoxCancelBtn = document.getElementById('message-box-cancel-btn'); // Assign new DOM element

            templateSelectionModal = document.getElementById('template-selection-modal');
            templateListContainer = document.getElementById('template-list');
            loadSelectedTemplateBtn = document.getElementById('load-selected-template-btn');

            tabButtons = document.querySelectorAll('.tab-button');
            tabContents = document.querySelectorAll('.tab-content');

            kanbanTodo = document.getElementById('kanban-todo').querySelector('.kanban-tasks');
            kanbanInProgress = document.getElementById('kanban-in-progress').querySelector('.kanban-tasks');
            kanbanCompleted = document.getElementById('kanban-completed').querySelector('.kanban-tasks');
            kanbanBacklog = document.getElementById('kanban-backlog').querySelector('.kanban-tasks');

            kanbanTodoCount = document.getElementById('kanban-todo').querySelector('.kanban-column-count');
            kanbanInProgressCount = document.getElementById('kanban-in-progress').querySelector('.kanban-column-count');
            kanbanCompletedCount = document.getElementById('kanban-completed').querySelector('.kanban-column-count');
            kanbanBacklogCount = document.getElementById('kanban-backlog').querySelector('.kanban-column-count');

            openFocusModeBtn = document.getElementById('open-focus-mode-btn');
            focusModeOverlay = document.getElementById('focus-mode-overlay');
            focusTimerDisplay = document.getElementById('focus-timer-display');
            focusTaskName = document.getElementById('focus-task-name');
            focusTaskDescription = document.getElementById('focus-task-description');
            focusChecklistItems = document.getElementById('focus-checklist-items');
            focusStartBtn = document.getElementById('focus-start-btn');
            focusPauseBtn = document.getElementById('focus-pause-btn');
            focusResetBtn = document.getElementById('focus-reset-btn');
            focusCompleteBtn = document.getElementById('focus-complete-btn');
            ambientSoundPlayer = document.getElementById('ambient-sound-player');
            toggleAmbientSoundBtn = document.getElementById('toggle-ambient-sound');
            focusModeCloseBtn = document.getElementById('focus-mode-close-btn');


            loadData();
            setupTabs();
            setupEventListeners();
            renderAll();
            updateFocusTimerDisplay();
            setAllBlockReminders(); // Set reminders on app load

            // Start focus reminder interval
            setInterval(showFocusReminder, 30 * 60 * 1000);

            // Hide loader after everything is rendered
            hideLoader();
        }

        // Ensure initApp runs after the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>
